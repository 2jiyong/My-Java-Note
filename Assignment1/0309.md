# 자바 학습 과제 1
자바의 타입, 변수, 배열
## 프리미티브 타입 종류와 값의 범위 그리고 기본 값
자바의 프리미티브 타입에는 `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`이 있다.

| 데이터 타입 | 크기                | 기본값 | 값의 범위 |
|------------|-------------------|--------|----------|
| `byte`     | 1바이트 (8비트)        | `0` | -128 ~ 127 |
| `short`    | 2바이트 (16비트)       | `0` | -32,768 ~ 32,767 |
| `int`      | 4바이트 (32비트)       | `0` | -2,147,483,648 ~ 2,147,483,647 |
| `long`     | 8바이트 (64비트)       | `0L` | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
| `float`    | 4바이트 (32비트)       | `0.0f` | 약 ±3.4E38 (7자리 정밀도) |
| `double`   | 8바이트 (64비트)       | `0.0d` | 약 ±1.8E308 (15자리 정밀도) |
| `char`     | 2바이트 (16비트)       | `'\u0000'` | `\u0000` ~ `\uffff` (유니코드) 
| `boolean`  | 1바이트 (JVM에 따라 다름) | `false` | `true` 또는 `false` | 
boolean은 논리상 1비트만 있어도 충분하지만 최소단위인 1바이트 단위로 접근하기 때문에 패딩을 더해 1바이트로 정렬한다.
## 프리미티브 타입과 레퍼런스 타입
자바에서 데이터 타입은 `프리미티브 타입`과 `레퍼런스 타입`으로 나뉜다.  
원시 타입은 `스택 영역`에 `실제 데이터 값`을 저장하고, 레퍼런스 타입은 실제 객체 는 `힙 영역`에 저장되고, 스택 영역엔 객체의 `메모리 주소`를 저장한다.
자바의 원시타입들은 각각 `래퍼 클래스`를 가지고 있어서 래퍼 클래스를 통해 원시타입을 `객체`로 사용할 수 있다.  
래퍼 클래스는 `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`이 있다.  
자바는 오토 박싱과 언박싱을 지원하여 래퍼 클래스와 원시 타입을 `자동으로 변환`해준다.  

자바에서 객체는 `힙`에 저장되며, 참조 타입의 변수는 `스택 메모리`에 힙 메모리 주소를 저장하고, 사용할 때마다 사용할 객체의 주소를 불러와 사용한다.  

원시 타입과 참조 타입의 기능적 차이에는 2가지가 있다.  
1. 참조 타입에는 Null을 담을 수 있지만 원시타입은 그렇지 못하다.
2. 원시 타입은 제네릭 타입에 사용할 수 없다.  
그래서 항상 List 제네릭 안에는 int 가 아닌 Integer를 사용한다.

## 상수와 리터럴
### 상수
상수는 단순히 설명하면 `변경할 수 없는 변수`이다.  
자바에서는 `final` 키워드를 사용하여 상수를 선언한다.  
상수는 보통 변하지 않는 값을 반복하여 사용할 떄 의미 있는 문자로 인식하기가 쉽다.  

### 리터럴
리터럴은 프로그래밍에서 `값 자체`를 나타낸다.  
코드에서 변수에 사용되거나 연산에 직접 사용되는 고정된 값이다.  
```java
int num = 10;  // 10은 정수 리터럴
String name = "Lee";  // "Lee"는 문자열 리터럴
```
원시 타입들만 리터럴이 있는 것이 아니라 `String` 리터럴과 `null` 리터럴도 있다.  
JVM은 리터럴을 효율적으로 사용하기 위해 `리터럴 풀`을 사용한다.  

예를 들어 문자열 리터럴 풀에선 문자열 리터럴을 관리하고 재사용한다.  
따라서 같은 문자열 리터럴은 `같은 주소`를 가리키게 된다.
하지만 new를 사용해서 생성한 경우엔 `Heap`에 새로운 객체가 생성되므로 리터럴 풀을 사용하지 않는다.  
리터럴 풀은 JVM의 메서드 영역의 `Runtime Constant Pool`에 위치한다고 한다.  

## 변수 선언 및 초기화하는 방법
### 변수
변수란 `하나의 값을 저장`할 수 있는 메모리 공간이다.  
앞에서 말했듯이 변수에 원시 데이터 타입을 저장하면 `실제 값`이 저장되고, 참조 타입을 저장하면 `메모리 주소`가 저장된다.  
변수를 사용하기 위해서는 변수를 무조건 먼저 `선언`해야 한다.  
변수의 `타입`과 `이름`을 지정해주면 된다.  

변수는 메모리 주소에 붙여진 이름이다.  
변수를 사용할 때는 변수 이름을 사용하여 메모리 주소에 접근한다.

```java
int num;  // int 타입의 num 변수 선언
```
원시 타입의 경우 변수를 선언하면 해당 변수의 데이터 타입에 맞는 메모리 공간이 할당된다.  
하지만 지역 변수는 초기화하지 않고 사용할 수 없고, 클래스에 선언된 인스턴스 변수는 초기화하지 않아도 기본값으로 초기화된다.  

참조 타입 변수는 Heap 메모리에 객체를 저장하고, Stack에는 객체의 주소(참조값)를 저장한다.
참조 타입 변수는 변수를 선언하면 Stack에 참조 변수만 생성되고, 객체를 생성해야 Heap에 메모리가 할당된다.  

변수를 선언한 후엔 초기화를 해야한다. 
대입 연산자 `=`을 사용하여 변수에 값을 할당한다.
```java
int num; // 변수 선언
num = 10;  // 변수 초기화
```
보통은 변수의 선언과 초기화를 동시에 한다.

## 변수의 스코프와 라이프타임
변수의 스코프라는 것은 변수를 어디에서 접근할 수 있는지를 의미한다.  
변수의 스코프는 선언된 위치에 따라 크게 세가지로 나뉜다.  
1. 클래스 변수 (static 변수) 
static 키워드를 사용해 선언되며, 클래스가 로드될 때 생성된다.(클래스가 사용되지 않으면 생성되지 않는다.)
데이터 영역에 생성되고, public을 이용하면 전역변수가 된다.  
클래스 변수는 같은 클래스 내에서 어디서든 접근이 가능하며 라이프 타임은 프로그램 실행부터 프로그램 종료 시까지이다.   
2. 인스턴스 변수 (멤버 변수)  
클래스 내부에서 선언되지만, static 키워드가 붙지 않은 변수이다.  
인스턴스를 생성해야 접근할 수 있으며 라이프 타임은 인스턴스가 생성된 이후부터 해제될 때까지이고, 인스턴스가 존재하는 동안 유지된다.  
3. 지역변수 
지역변수는 메서드 안에서 선언된 변수로, 선언된 메서드 안에서만 사용이 가능하다.  
함수를 호출하면 스택 메모리에 생성된다.  
함수가 종료되면 스택이 사라지고, 그 안에 있던 변수들은 사라진다.  
라이프타임은 변수가 선언되고, 해당 블록이 끝날 때까지이다.  
메서드 안에서도 if, for, while 등의 블록 안에서 선언된 변수는 블록 변수라고도 한다.  
블록 내에서 선언된 변수들은 해당 블록 내에서만 사용이 가능하고, 블록이 끝나면 소멸된다.   

## 타입 변환, 캐스팅 그리고 타입 프로모션
타입 변환, 캐스팅, 타입 프로모션은 모두 자바에서 데이터 타입을 변환하는 개념이다.  
타입 변환에는 두 가지 종류가 있는데 하나는 묵시적 타입 변환, 하나는 명시적 타입 변환(캐스팅)이다.  
### 묵시적 타입 변환 (타입 프로모션)
작은 크기의 데이터 타입을 큰 크기의 데이터 타입으로 변환할 때는 자동으로 타입 변환이 이루어진다.  

byte → short → int → long → float → double  
이 방향으로의 타입 변환은 프로그램 실행 도중에 자동으로 이루어진다.  
long은 8바이트이고 float는 4바이트인데 왜 자동으로 타입 변환이 이루어질까?  
long이 표현할 수 있는 크기보다 float가 표현할 수 있는 크기가 더 크기 때문에 자동으로 변환된다.  
하지만 long이 float로 변환될 때 데이터 손실이 발생할 수 있다는 점을 유의해야 한다.
```java
int intVal = 100;
double doubleVal = intVal; //int가 자동으로 double로 형변환 됨
```
묵시적 형 변환은 작은 크기의 데이터 타입을 큰 크기의 데이터 타입으로 할당할 때 뿐만 아니라, 연산 시에도 이루어진다.  
데이터 연산은 기본적으로 같은 타입의 피연산자 간에만 수행되기 때문에 서로 다른 타입의 피연산자 끼리 연산을 한다면 더 큰 타입으로 형 변환된 뒤 연산을 실행한다.

### 명시적 타입 변환 (캐스팅)
묵시적 형 변환이 작은 크기의 데이터 타입을 큰 크기의 데이터 타입으로 변환할 때 자동적으로 일어났다면, 명시적 타입 변환은 큰 크기의 데이터 타입을 
작은 크기의 데이터 타입으로 변환할 때 타입 캐스트 연산자 (double) 등 을 사용하여 강제로 형 변환하는 것을 말한다.  
주의할 점은 강제적인 형변환이기 때문에 데이터의 손실이 일어날 수 있어 정확한 연산을 수행할 수 없을 수도 있다는 점이다.  
이를 막기 위해선 어떤 값을 다른 타입으로 변환하고자 할 때, 변환될 타입의 최소값과 최대값을 벗어나는지 검사하고, 벗어난다면 변환하지 않는 식으로 타입 변환 가드를 칠 수 있다.  

## 1차 및 2차 배열 선언하기
### 1차 배열 선언하기
```java
int[] arr = new int[5]; // 크기가 5인 배열 선언, 선언시 기본값으로 초기화됨
int[] arr = {1,2,3,4,5}; // 배열 선언과 초기화를 동시에 함

//int[] arr;
//arr = {1,2,3,4,5};
// 오류 발생 : 배열 리터럴을 사용하려면 항상 선언과 동시에 해줘야 함
int[] arr;
arr = new int[]{1,2,3,4,5};
//이렇게 해줘야 함
```

### 2차 배열 선언하기 
```java
int[][] scores = new int[2][3];
int[][] arr = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
};
```

## 타입 추론과 var
타입 추론은 컴파일러가 변수의 데이터 타입을 자동으로 추론하는 기능이다.  
주로 제네릭이나 var를 사용할 때 타입 추론이 적용된다.  
```java
List<String> list2 = new ArrayList<>(); // 타입 추론
var message = "Hello, Java"; // 자동으로 String으로 추론
```
var를 사용하면 컴파일러는 개발자가 입력한 초기화 값으로 타입을 유추하기 때문에 반드시 데이터를 초기해 줘야 사용이 가능하다.  
var를 사용하면 코드를 더 간결하게 만들고, 중복된 타입 선언을 줄여주며, 가독성을 향상시킬 수 있다.  
하지만 타입이 명확하지 않은 순간에 var를 사용하면 오히려 가독성이 떨어질 위험성이 있으므로 남용하지 않는 것이 좋다.  





